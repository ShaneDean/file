# 前言

[参考1](https://www.cnblogs.com/bakari/p/10450711.html)，[参考2](https://www.cnblogs.com/bakari/p/10494773.html)，[参考3](https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/index.html)

# 网络背景

网络设备

-   中继器  物理层
-   网桥、交换机    数据链路层
-   路由器  网络层

网络设备图 

# bridge

linux上用来做二层协议交换的设备，如交换机、网桥相同。bridge可以和Linux上的其他网络设备实例连接，attach一个从设备，实现类似显示世界的交换机+用户终端之间连接的一根网线。

bridge可以根据报文的mac信息进行广播、转发、废弃处理.

 Bridge 自带了一个隐藏端口和寄主 Linux 系统自动连接，Linux 上的程序可以直接从这个端口向 Bridge 上的其他端口发数据。所以当一个 Bridge 拥有一个网络设备时，如 bridge0 加入了 eth0 时，实际上 bridge0 拥有两个有效 MAC 地址，一个是 bridge0 的，一个是 eth0 的，他们之间可以通讯。由此带来一个有意思的事情是，Bridge 可以设置 IP 地址。通常来说 IP 地址是三层协议的内容，不应该出现在二层设备 Bridge 上。但是 Linux 里 Bridge 是通用网络设备抽象的一种，只要是网络设备就能够设定 IP 地址。当一个 bridge0 拥有 IP 后，Linux 便可以通过路由表或者 IP 表规则在三层定位 bridge0，此时相当于 Linux 拥有了另外一个隐藏的虚拟网卡和 Bridge 的隐藏端口相连，这个网卡就是名为 bridge0 的通用网络设备，IP 可以看成是这个网卡的。当有符合此 IP 的数据到达 bridge0 时，内核协议栈认为收到了一包目标为本机的数据，此时应用程序可以通过 Socket 接收到它。
 
Bridge 的实现当前有一个限制：当一个设备被 attach 到 Bridge 上时，那个设备的 IP 会变的无效，Linux 不再使用那个 IP 在三层接受数据。举例如下：如果 eth0 本来的 IP 是 192.168.1.2，此时如果收到一个目标地址是 192.168.1.2 的数据，Linux 的应用程序能通过 Socket 操作接受到它。而当 eth0 被 attach 到一个 bridge0 时，尽管 eth0 的 IP 还在，但应用程序是无法接受到上述数据的。此时应该把 IP 192.168.1.2 赋予 bridge0。

另外需要注意的是数据流的方向。对于一个被 attach 到 Bridge 上的设备来说，只有它收到数据时，此包数据才会被转发到 Bridge 上，进而完成查表广播等后续操作。当请求是发送类型时，数据是不会被转发到 Bridge 上的，它会寻找下一个发送出口。用户在配置网络时经常忽略这一点从而造成网络故障。 


# vlan设备


vlan 虚拟网络，原理是在二层协议里插入额外的 VLAN 协议数据（tag）,同时保持和传统二层设备的兼容性

linux中的vlan设备是对802.1.q协议的一种内部软件实现，模拟现实世界的802.1.q交换机

vlan设备以母子关系成对出现，母设备相当于现实世界中的交换机trunck口用于连接上级网络，自设备相当于普通接口，用于连接下级网络

母子关系为一对多，子设备的数据发送时，数据将被加入WLAN tag然后从母设备中发送出去。

当母设备收到一包数据时，它将会分析其中的 VLAN Tag，如果有对应的子设备存在，则把数据转发到那个子设备上并根据设置移除 VLAN Tag，否则丢弃该数据。

母设备只能用于接收数据、子设备只能用于发送数据。可以把母设备视为现世界的交换机，下级接口通过子设备连接到寄主linux系统网络里，上级接口 通过母设备连接到上级网络，当母设备是物理网卡时候上级网络是外界真实网络，当母设备是另外一个linux虚拟网络设备时上级网络仍然是寄主linux系统网络。

不同于现实交换机的地方，linux vlan设备只有隔离功能，没有交换功能，需要借助bridge实现交换功能。

# tap/tun

TUN/TAP 设备是一种让用户态程序向内核协议栈注入数据的设备，tap工作在三层，tun工作在二层，使用较多的是 TAP 设备。

它们驱动程序

-   字符设备驱动    ：负责数据包在内核空间和用户空间的传递
    -   tap :   /dev/tap0
    -   tun :   /dev/net/tun

当一个设备被创建时，在 Linux 设备文件目录下将会生成一个对应 char 设备，用户程序可以像打开普通文件一样打开这个文件进行读写。

tap/tun 设备文件就像一个管道，一端连接着用户空间，一端连接着内核空间。当用户程序向文件写数据时，内核就可以从对应的接口读到数据，反之，内核可以通过相反的方式向用户程序发送数据。

-   网卡驱动        ：负责数据包在tcp/ip协议栈上的传输和处理


# veth-pair

成对出现的一种虚拟网络设备，一端连着协议栈，一端连着彼此，数据从一端出，从另一端进。

送到一端请求发送的数据总是从另一端以请求接受的形式出现。该设备不能被用户程序直接操作，但使用起来比较简单。创建并配置正确后，向其一端输入数据，VETH 会改变数据的方向并将其送入内核网络核心，完成数据的注入。在另一端能读到此数据。

常用来连接不同的虚拟网络组件，构建大规模的虚拟网络拓扑，如linux bridge \ ovs \ lxc

# macvlan

macvlan 子接口和母接口完全独立，可以单独配置mac和ip， 传统vlan的子接口和母接口公用相同地址。

macvlan网络模式

-   private 模式

母接口下的子接口之间相互独立，不能通信。即使外部的物理交换机导流也会被丢掉。

-   vepa模式(virtual ethernet port aggregator) （默认）

可以借助外部支持802.1Qbg/VPEA 夹发(hairpin) 功能的交换机（软硬都可）来传导流量。

-   bridge 模式

模拟linux bridge功能。每个接口的mac地址都是已知，不需要学习。子接口可以直接通信。

-   passthru 模式

子接口和母接口只能直连，一般用于子接口桥接和创建vlan子接口的情况。

# mactap

mactap接收到包之后不交给协议栈，而是交给一个tabx文件处理，通过这个文件来和用户态完成直接通信。